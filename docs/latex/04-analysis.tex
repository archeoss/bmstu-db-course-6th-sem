\section{Аналитический раздел}

В данном разделе описана структура теста Тьюринга.  
Представлен анализ способов хранения данных и систем управления базами данных, оптимальных для решения поставленной задачи. 

\subsection{Формализация задачи}
Тест Тьюринга --- это метод оценки способности машины производить интеллектуальные действия, сравнивая ее поведение с поведением человека в решении задач. 
Тест заключается в том, что человек задает вопросы другому человеку и компьютеру, а затем пытается определить, от кого пришли ответы. 
Если компьютер может убедительно имитировать поведение человека, то он считается способным производить интеллектуальные действия.

\img{100mm}
{turing.png}
{Тест Тьюринга}

Тьюринг в своей работе~\cite{10.1093/mind/LIX.236.433} описывает следующий вид игры. Предположим, что у нас есть человек, машина и эксперт. Эксперт находится в комнате, отделенной от другого человека и машины. Цель игры состоит в том, чтобы эксперт определил, кто из двух является человеком, а кто машиной. Эксперт знает человека и машину по меткам «X» и «Y» --- но, по крайней мере в начале игры, не знает, кто из них человек и кто -- машина --- и в конце игры он должен сказать либо «X --- это человек, а Y --- машина», либо «X --- это машина, а Y --- человек».
Эксперту разрешается задавать человеку и машине вопросы следующего вида: «Скажите, пожалуйста, X, играет ли X в шахматы?» Кто бы из машины и другого человека ни был X, он должен отвечать на вопросы, адресованные X. Цель машины состоит в том, чтобы попытаться заставить эксперта ошибочно заключить, что машина --- это другой человек; цель другого человека состоит в том, чтобы попытаться помочь эксперту правильно идентифицировать машину.~\cite{sep-turing-test}

Следует отметить, что во времена Тьюринга, было ограничение, что ответы поступали через ограниченные врменные рамки, поскольку время ответа компьютера было гораздо больше, чем у человека. 
Сегодня это ограничение сохраняется, однако из-за обратного: реакция компьютера быстрее, чем реакция человека.

\subsection{Способы хранения данных}

Для решения задачи хранения теста Тьюринга необходимо хранить следующие данные:
\begin{enumerate}  
  \item Данные о человеке, машине и эксперте;
  \item Данные о заданных вопросах и полученных ответах;
  \item Данные, о связях между вопросами и ответами. 
\end{enumerate}

Поскольку в конце теста выносится вердикт о том, является ли отвечающий машиной или человеком, необходимо также хранить какие ответы были даны в каком порядке и каким актором. 
Эти данные должны быть доступны для обработки и сравнения в процессе игры.
 
Один из способов хранения данных --- это использование реляционных баз данных. В этом случае можно создать таблицы для каждого объекта (люди, машины и эксперты, вопросы и ответы, и т.д.) и связать их отношениями. 
Например, таблицы <<Person>>, <<Computer>> и <<Interrogator>> могут быть связаны через внешние ключи. 
Это является надежным и проверенным способом хранения данных.

Однако более эффективный способ хранения данных --- это использование графовых баз данных (GDB), таких как SurrealDB или Neo4j. 
В этом случае каждый объект может быть представлен узлом графа, а отношения между объектами --- ребрами графа~\ref{img:graph}.

\img{100mm}
{graph}
{Представление базы данных в виде графа}

Ключевым понятием системы является граф (или ребро, или взаимосвязь). Граф связывает элементы данных в хранилище с набором узлов и ребер, причем ребра представляют отношения между узлами. Отношения позволяют напрямую связывать данные в хранилище и во многих случаях извлекать их с помощью одной операции. Базы данных графов удерживают отношения между данными в качестве приоритета. Запрашивать отношения быстро, потому что они постоянно хранятся в базе данных. Отношения можно интуитивно визуализировать с помощью графов, что делает их полезными для сильно взаимосвязанных данных~\cite{graph-exp}.
Поскольку графовая модель данных более естественным образом отображает связи между объектами, это делает ее более подходящей для задач, связанных с анализом связей и отношений между данными. В графовых базах данных нет необходимости использовать сложные JOIN-запросы, что может существенно упростить запросы к данным.

Графовые базы данных также обеспечивают быстрый доступ к данным по отношениям, что делает их эффективными при работе с глубоко связанными данными. Они также позволяют легко добавлять новые данные в граф без необходимости изменения схемы базы данных.
Однако, реляционные базы данных обладают более высокой надежностью и могут обеспечивать лучшую производительность при выполнении сложных запросов, особенно если используются правильно настроенные индексы.

Таким образом, выбор между реляционными базами данных и графовыми зависит от конкретных требований проекта.
В контексте данной работы, графовая модель подходит больше, чем реляционная, потому что тест Тьюринга включает в себя множество связей между объектами (человек, машина, эксперт, вопросы и ответы и т.д.), которые можно представить в виде графа.

Графовая модель также становится еще более привлекательной, если вспомнить какая идея была обозначена в начале данной работы: создание инструмента для улучшения искусственного интеллекта. В большинстве случаев ИИ работает не со стандартными <<табличными>> данными, а данными, представленных в виде графа. Таким образом, схожая структура данных внутри СУБД поможет разработать более гибкую и быстродействующую систему при меньших затраченных ресурсах

На рис.~\ref{img:graph-bench} можно увидеть результаты сравнения 3 различных баз данных: реляционной (PostgreSQL), графовой (Neo4j) и мультимодельной (ArangoDB).

\img{100mm}
{graph-bench}
{Сравнение времени работы различных баз данных над атомарными операциями.}

\clearpage

\subsection{Системы управления базами данных}

Для выбора системы управления базами данных необходимо учитывать требования к производительности и масштабируемости приложения.

Реляционные базы данных имеют высокую надежность и поддерживают ACID-свойства транзакций. Они также обеспечивают хорошую производительность при выполнении сложных запросов. Однако, они требуют дополнительного управления индексами и ключевыми полями.

Графовые базы данных обеспечивают высокую производительность при работе с глубоко связанными данными. Граф связывает элементы данных в хранилище с набором узлов и ребер, причем сами ребра представляют отношения между узлами. Отношения позволяют напрямую связывать данные в хранилище и во многих случаях извлекать их с помощью одной операции. Отношения между данными в подобных системах имеют приоритет над самими данными, поэтому запрос по отношениям является крайне быстрой операцией, поскольку они постоянно хранятся в базе данных. Также отношения можно интуитивно визуализировать с помощью графов, что делает их полезными для сильно взаимосвязанных данных. 

\subsubsection{SurrealDB}

SurrealDB --- мультимодельная NewSQL база данных, которая работает в режиме полной схемы (\texttt{SCHEMAFULL}) или без схемы (\texttt{SCHEMALESS}), с таблицами, ссылками на записи между документами (без \texttt{JOIN}) и функциями моделирования базы данных на основе графов~\cite{surrealdb}.

Благодаря использованию SurrealDB особых методов сегментирования и репликации, становится возможным повысить производительность за счет распределения нагрузки между несколькими компьютерами~\cite{surrealarch}.

Также особая архитектура базы данных позволяет работать как в оперативной памяти (\texttt{in-memory}), на дисковом пространстве (\texttt{on-disk}) или как распределенная база данных, используя TiKV~\cite{tikv}.

Поскольку SurrealDB --- мультимодельная база данных, становится также возможным классические реляционные методики проектирования баз данных, что повышает гибкость итоговой системы.

\subsubsection{Neo4j}

Neo4j --- это графовая база данных, которая позволяет хранить, управлять и анализировать связанные данные. 
Она была разработана с учетом графовой модели данных, в которой данные представлены в виде узлов (вершин) и связей (ребер)~\cite{neo4j}. 

Одним из преимуществ Neo4j является то, что она позволяет эффективно моделировать и анализировать сложные связи между данными, такие как социальные сети, географические карты и сети предприятий.
Это делает ее очень полезной для приложений, которые требуют быстрого доступа к сложным связным данным и быстрой обработки запросов.

Однако поскольку Neo4j --- исключительно графовая база данных, хранение и получение данных без каких-либо связей друг с другом может вызвать проблемы с производительностью, вне зависимости от размера запроса~\cite{neocons}.

\subsection{Выбор СУБД для решения задачи}

Для решения задачи теста Тьюринга необходимо выбрать графовую базу данных, поскольку графовая модель данных более естественным образом отображает связи между объектами. 

Среди графовых баз данных можно выделить две наиболее подходящие системы: SurrealDB и Neo4j. Обе СУБД обеспечивают быстрый доступ к данным по отношениям, что делает их эффективными при работе с глубоко связанными данными. 

Однако SurrealDB имеет дополнительные преимущества перед Neo4j. Она является мультимодельной базой данных, что позволяет эффективное хранение и получение несвязанных данных, где Neo4j может испытывать определенные проблемы.

\subsection*{Вывод}

В данном разделе:
\begin{itemize}
  \item[$-$] рассмотрена сущность и стурктура теста Тьюринга;
  \item[$-$] проанализированы способы хранения информации для системы и выбраны оптимальные способы для решения поставленной задачи;
  \item[$-$] были рассмотрены два различных типа баз данных: реляционные и графовые;
  \item[$-$] было выявлено, что для решения задачи теста Тьюринга наиболее подходящей является графовая база данных, а конкретно SurrealDB.
\end{itemize}







% При работе с базами данных возникает проблема кэширования данных. Кэш - это временное хранилище для часто запрашиваемых данных, которые сохраняются в оперативной памяти для быстрого доступа.
%
% Одна из проблем кэширования данных - это несогласованность данных. Если данные в базе данных изменены, а кэш не обновлен, то приложение может использовать устаревшие данные.
%
% Другая проблема - это проблема выборки (cache miss). Если запрашиваемые данные не находятся в кэше, то приложение должно выполнить запрос к базе данных, что может замедлить работу приложения.
%
% \section{Методы решения проблем кэширования данных}
%
% Для решения проблем кэширования данных можно использовать различные подходы:
% \begin{itemize}
%     \item[$-$] Использование инвалидации кэша. При изменении данных в базе данных, кэш помечается как недействительный (invalidated), и приложение обновляет данные при следующем запросе.
%     \item[$-$] Использование временных меток (timestamps). При каждом изменении данных в базе данных, записывается временная метка, которая позволяет определить, являются ли данные в кэше устаревшими.
%     \item[$-$] Использование стратегий вытеснения (cache eviction). Если кэш заполнен, то необходимо выбрать данные для удаления из кэша. Существуют различные стратегиивытеснения, включая:
% \end{itemize}
%
% \begin{enumerate}
%     \item Наименее используемые (Least Recently Used, LRU) - удаляет элементы, которые были меньше всего запрашиваемы за последнее время.
%     \item Наименее часто используемые (Least Frequently Used, LFU) - удаляет элементы, которые были запрашиваемы наименее количество раз.
%     \item Случайные (Random) - случайным образом выбирает элементы для удаления.
%     \item По времени жизни (Time to Live, TTL) - удаляет элементы, которые превысили заданный период жизни в кэше.
% \end{enumerate}
%
% Выбор конкретной стратегии зависит от требований и характеристик приложения, а также от доступных ресурсов и ограничений. 
