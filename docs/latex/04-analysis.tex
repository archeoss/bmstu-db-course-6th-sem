\section{Аналитический раздел}

В данном разделе описана структура теста Тьюринга.  
Представлен анализ способов хранения данных и систем управления базами данных, оптимальных для решения поставленной задачи. Описаны  
проблемы кэшированных данных и представлены методы их решения.

\subsection{Формализация задачи}
Тест Тьюринга --- это метод оценки способности машины производить интеллектуальные действия, сравнивая ее поведение с поведением человека в решении задач. Тест заключается в том, что человек задает вопросы человеку и компьютеру, а затем пытается определить, от кого пришли ответы. Если компьютер может убедительно имитировать поведение человека, то он считается способным производить интеллектуальные действия.

\img{100mm}
{turing.png}
{Тест Тьюринга}

Тьюринг в своей работе~\cite{10.1093/mind/LIX.236.433} описывает следующий вид игры. Предположим, что у нас есть человек, машина и эксперт. Эксперт находится в комнате, отделенной от другого человека и машины. Цель игры состоит в том, чтобы эксперт определил, кто из двух является человеком, а кто машиной. Эксперт знает человека и машину по меткам «X» и «Y» --- но, по крайней мере в начале игры, не знает, кто из них человек и кто -- машина --- и в конце игры он должен сказать либо «X --- это человек, а Y --- машина», либо «X --- это машина, а Y --- человек».
Эксперту разрешается задавать человеку и машине вопросы следующего вида: «Скажите, пожалуйста, X, играет ли X в шахматы?» Кто бы из машины и другого человека ни был X, он должен отвечать на вопросы, адресованные X. Цель машины состоит в том, чтобы попытаться заставить эксперта ошибочно заключить, что машина --- это другой человек; цель другого человека состоит в том, чтобы попытаться помочь эксперту правильно идентифицировать машину.~\cite{sep-turing-test}

Следует отметить, что во времена Тьюринга, было ограничение, что ответы поступали через ограниченные врменные рамки, поскольку время ответа компьютера было гораздо больше, чем у человека. 
Сегодня это ограничение сохраняется, однако из-за обратного: реакция компьютера быстрее, чем реакция человека.

\subsection{Способы хранения данных}

Для решения задачи теста Тьюринга необходимо хранить данные о человеке, машине и эксперте. Также необходимо хранить данные о заданных вопросах и полученных ответах. Хранить данные, на какие вопросы были даны какие ответы. Поскольку в конце теста выносится вердикт о том, является ли отвечающий машиной или человеком, необходимо также хранить какие ответы были даны в каком порядке и каким актором. Эти данные должны быть доступны для обработки и сравнения в процессе игры.

Один из способов хранения данных --- это использование реляционных баз данных. В этом случае можно создать таблицы для каждого объекта (люди, машины и эксперты, вопросы и ответы, и т.д.) и связать их отношениями. Например, таблицы «Person», «Machine» и «Interrogator» могут быть связаны через внешние ключи. Это является надежным и проверенным способом хранения данных.

Однако более эффективный способ хранения данных --- это использование графовых баз данных (GDB), таких как SurrealDB или Neo4j. В этом случае каждый объект может быть представлен узлом графа, а отношения между объектами --- ребрами графа.~\ref{img:graph}

\img{100mm}
{graph}
{Представление базы данных в виде графа}

Ключевым понятием системы является граф (или ребро, или взаимосвязь). Граф связывает элементы данных в хранилище с набором узлов и ребер, причем ребра представляют отношения между узлами. Отношения позволяют напрямую связывать данные в хранилище и во многих случаях извлекать их с помощью одной операции. Базы данных графов удерживают отношения между данными в качестве приоритета. Запрашивать отношения быстро, потому что они постоянно хранятся в базе данных. Отношения можно интуитивно визуализировать с помощью баз данных графов, что делает их полезными для сильно взаимосвязанных данных.~\cite{graph-exp}.
Поскольку графовая модель данных более естественным образом отображает связи между объектами, это делает ее более подходящей для задач, связанных с анализом связей и отношений между данными. В графовых базах данных нет необходимости использовать сложные JOIN-запросы, что может существенно упростить запросы к данным.

Графовые базы данных также обеспечивают быстрый доступ к данным по отношениям, что делает их эффективными при работе с глубоко связанными данными. Они также позволяют легко добавлять новые данные в граф без необходимости изменения схемы базы данных.
Однако, реляционные базы данных обладают более высокой надежностью и могут обеспечивать лучшую производительность при выполнении сложных запросов, особенно если используются правильно настроенные индексы.

Таким образом, выбор между реляционными базами данных и графовыми зависит от конкретных требований проекта.
В контексте данной работы, графовая модель подходит больше, чем реляционная, потому что тест Тьюринга включает в себя множество связей между объектами (человек, машина, эксперт, вопросы и ответы и т.д.), которые можно представить в виде графа.

Графовая модель также становится еще более привлекательной, если вспомнить какая идея была обозначена в начале данной работы: создание инструмента для улучшения искусственного интеллекта. В большинстве случаев ИИ работает не со стандартными <<табличными>> данными, а данными, представленных в виде графа. Таким образом, схожая структура данных внутри СУБД поможет разработать более гибкую и быстродействующую систему при меньших затраченных ресурсах

На рис.~\ref{img:graph-bench} можно увидеть результаты сравнения 3 различных баз данных: реляционной (PostgreSQL), графовой (Neo4j) и мультимодельной (ArangoDB).

\img{100mm}
{graph-bench}
{Сравнение времени работы различных баз данных над атомарными операциями.}

\clearpage

\subsection{Системы управления базами данных}

Для выбора системы управления базами данных необходимо учитывать требования к производительности и масштабируемости приложения.

Реляционные базы данных имеют высокую надежность и поддерживают ACID-свойства транзакций. Они также обеспечивают хорошую производительность при выполнении сложных запросов. Однако, они требуют дополнительного управления индексами и ключевыми полями.

Графовые базы данных обеспечивают высокую производительность при работе с глубоко связанными данными. Граф связывает элементы данных в хранилище с набором узлов и ребер, причем сами ребра представляют отношения между узлами. Отношения позволяют напрямую связывать данные в хранилище и во многих случаях извлекать их с помощью одной операции. Отношения между данными в подобных системах имеют приоритет над самими данными, поэтому запрос по отношениям является крайне быстрой операцией, поскольку они постоянно хранятся в базе данных. Также отношения можно интуитивно визуализировать с помощью баз данных графов, что делает их полезными для сильно взаимосвязанных данных. 

\subsubsection{SurrealDB}

SurrealDB --- мультимодельная NewSQL база данных, которая работает в режиме полной схемы или без схемы, с таблицами, ссылками на записи между документами (без JOIN) и функциями моделирования базы данных на основе графов.

Благодаря использованию SurrealDB особых методов сегментирования и репликации, становится возможным повысить производительность за счет распределения нагрузки между несколькими компьютерами.

Также особая архитектура базы данных позволяет работать как in-memory, on-disk или как распределенная база данных, используя TiKV.

Поскольку SurrealDB --- мультимодельная база данных, становится также возможным классические реляционные методики проектирования баз данных, что повышает гибкость итоговой системы.

\subsubsection{Neo4j}

Neo4j --- это графовая база данных, которая позволяет хранить, управлять и анализировать связанные данные. Она была разработана с учетом графовой модели данных, в которой данные представлены в виде узлов (вершин) и связей (ребер). 

Одним из преимуществ Neo4j является то, что она позволяет эффективно моделировать и анализировать сложные связи между данными, такие как социальные сети, географические карты и сети предприятий. Это делает ее очень полезной для приложений, которые требуют быстрого доступа к сложным данным и быстрой обработки запросов.

Однако поскольку Neo4j ---  исключительно графовая база данных, хранение и получение данных без каких-либо связей друг с другом может вызвать проблемы с производительностью, вне зависимости от размера запроса.

\subsection{Выбор СУБД для решения задачи}

Для решения задачи теста Тьюринга необходимо выбрать графовую базу данных, поскольку графовая модель данных более естественным образом отображает связи между объектами. 

Среди графовых баз данных можно выделить две наиболее подходящие системы: SurrealDB и Neo4j. Обе СУБД обеспечивают быстрый доступ к данным по отношениям, что делает их эффективными при работе с глубоко связанными данными. 

Однако SurrealDB имеет дополнительные преимущества перед Neo4j. Она является мультимодельной базой данных, что позволяет эффективное хранение и получение несвязанных данных, где Neo4j может испытывать определенные проблемы.

\subsection{Проблемы кэширования данных и их решение}

Одной из проблем, связанных с хранением и обработкой данных в базах данных, является производительность. Возможны ситуации, когда приложение должно быстро получать данные из базы данных, но поиск этих данных может занять много времени. Кэширование может помочь решить эту проблему.

Кэширование --- это метод хранения данных в памяти для быстрого доступа к ним. Кэш представляет собой временное хранилище данных, которые часто запрашиваются из базы данных. Если данные уже находятся в кэше, приложение может получить доступ к ним намного быстрее, чем если они были запрошены непосредственно из базы данных.

Для кэширования данных можно использовать NoSQL in-memory базы данных. Такие базы данных хранят данные в оперативной памяти, что обеспечивает более быстрый доступ к данным. Примерами таких баз данных могут считаться Redis и Tarantool.
Однако использование кэширования может столкнуться со следующими проблемами:
\begin{enumerate}
  \item Неконсистентность данных. Если данные изменились в базе данных, но не обновлены в кэше, то будет получен неверный результат. Решением этой проблемы является использование механизма инвалидации кэша, который обновляет данные в кэше при изменении в базе данных.
  \item Ограничение объема памяти. Кэш может занять значительное количество оперативной памяти, что может привести к ограничениям по объему хранимых данных. Решением этой проблемы может быть использование LRU-алгоритма (Least Recently Used), который удаляет менее используемые данные из кэша для освобождения памяти.
  \item Потеря данных при сбое системы. Если происходит сбой системы или выключение сервера, то данные в кэше могут быть потеряны. Решением этой проблемы может быть использование репликации и бекапов для сохранения данных.
  \item Производительность записи в базу данных. Использование кэша может повысить производительность чтения данных, но при записи данных в базу производительность может снижаться из-за необходимости обновления как в базе данных, так и в кэше. Решением этой проблемы является оптимизация процесса записи данных и использование асинхронных запросов.
\end{enumerate}

\subsection{Обзор in-memory NoSQL СУБД}

\subsubsection{Tarantool}

Tarantool \cite{tarantool} --- это платформа in-memory вычислений с гибкой схемой хранения данных для эффективного создания высоконагруженных приложений. Включает себя базу данных и сервер приложений на языке программирования Lua \cite{lua}.

Tarantool обладает высокой скоростью работы по сравнению с традиционными СУБД. При этом, в рассматриваемой платформе для транзакций реализованы свойства ACID, репликация master-slave \cite{master-slave} и master-master \cite{master-master}, как и в традиционных СУБД.

Для хранения данных используется кортежи (англ. tuple) данных. Кортеж -- это массив не типизированных данных. Кортежи объединяются в спейсы (англ. space), аналоги таблицы из реляционной модели хранения данных. Спейс -- коллекция кортежей, кортеж -- коллекция полей.

В Tarantool реализован механизм <<снимков>> текущего состояния хранилища и журналирования всех операций, что позволяет восстановить состояние базы данных после ее перезагрузки.\\

\subsubsection{Redis}
Redis \cite{redis} --- резидентная система управлениями базами данных класса NoSQL с открытым исходным кодом. Основной структурой данных, с которой работает Redis является структура типа <<ключ-значение>>. Данная СУБД используется как для хранения данных, так и для реализации кэшей и брокеров сообщений.

Redis хранит данные в оперативной памяти и снабжена механизмом <<снимков>> и журналирования, что обеспечивает постоянное хранение данных. Предоставляются операции для реализации механизма обмена сообщениями в шаблоне <<издатель-подписчик>>: с его помощью приложения могут создавать программные каналы, подписываться на них и помещать в эти каналы сообщения, которые будут получены всеми подписчиками. Существует поддержка репликации данных типа master-slave, транзакций и пакетной обработки команд.

Все данные Redis хранит в виде словаря, в котором ключи связаны со своими значениями. Ключевое отличие Redis от других хранилищ данных заключается в том, что значения этих ключей не ограничиваются строками. Поддерживаются следующие абстрактные типы данных:

\begin{itemize}
\item строки;
\item списки;
\item множества;
\item хеш-таблицы;
\item упорядоченные множества.
\end{itemize}

Тип данных значения определяет, какие операции доступные для него; поддерживаются высокоуровневые операции: например, объединение, разность или сортировка наборов.

\subsection{Выбор СУБД для кэширования данных}

Для кэширования данных можно использовать любую in-memory NoSQL базу данных. Обе системы, Tarantool и Redis, обеспечивают быстрый доступ к данным в памяти и имеют механизмы инвалидации кэша. 

Однако, Tarantool обладает дополнительными преимуществами перед Redis. Она предоставляет возможность хранения данных в гибком формате кортежей, что позволяет более эффективно организовывать данные в базе данных. Также в Tarantool реализованы свойства ACID для транзакций и механизм репликации данных, что делает ее более надежной для использования в высоконагруженных приложениях.

Поэтому для решения задачи кэширования данных лучше выбрать Tarantool.

\subsection*{Вывод}

В данном разделе были рассмотрены различные типы баз данных: реляционные и графовые, а также обзор in-memory NoSQL СУБД. Было выявлено, что для решения задачи теста Тьюринга наиболее подходящей является графовая база данных, а конкретно SurrealDB. Для кэширования данных можно использовать любую in-memory NoSQL базу данных, но наилучшим выбором для этой задачи является Tarantool.








% При работе с базами данных возникает проблема кэширования данных. Кэш - это временное хранилище для часто запрашиваемых данных, которые сохраняются в оперативной памяти для быстрого доступа.
%
% Одна из проблем кэширования данных - это несогласованность данных. Если данные в базе данных изменены, а кэш не обновлен, то приложение может использовать устаревшие данные.
%
% Другая проблема - это проблема выборки (cache miss). Если запрашиваемые данные не находятся в кэше, то приложение должно выполнить запрос к базе данных, что может замедлить работу приложения.
%
% \section{Методы решения проблем кэширования данных}
%
% Для решения проблем кэширования данных можно использовать различные подходы:
% \begin{itemize}
%     \item[$-$] Использование инвалидации кэша. При изменении данных в базе данных, кэш помечается как недействительный (invalidated), и приложение обновляет данные при следующем запросе.
%     \item[$-$] Использование временных меток (timestamps). При каждом изменении данных в базе данных, записывается временная метка, которая позволяет определить, являются ли данные в кэше устаревшими.
%     \item[$-$] Использование стратегий вытеснения (cache eviction). Если кэш заполнен, то необходимо выбрать данные для удаления из кэша. Существуют различные стратегиивытеснения, включая:
% \end{itemize}
%
% \begin{enumerate}
%     \item Наименее используемые (Least Recently Used, LRU) - удаляет элементы, которые были меньше всего запрашиваемы за последнее время.
%     \item Наименее часто используемые (Least Frequently Used, LFU) - удаляет элементы, которые были запрашиваемы наименее количество раз.
%     \item Случайные (Random) - случайным образом выбирает элементы для удаления.
%     \item По времени жизни (Time to Live, TTL) - удаляет элементы, которые превысили заданный период жизни в кэше.
% \end{enumerate}
%
% Выбор конкретной стратегии зависит от требований и характеристик приложения, а также от доступных ресурсов и ограничений. 
