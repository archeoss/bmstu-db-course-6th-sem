\section{Технологический раздел}

\subsection{Средства реализации}

Основным языком программирования является мультипарадигменный язык Rust\cite{rust}.
\begin{itemize}
    \item[$-$] Одно из главных достоинств данного языка это гарантия безопасной работы с памятью при помощи системы
    статической проверки ссылок, так называемый Borrow Checker\cite{borrow-checker}.
    \item[$-$] Отсутствие сброщика мусора, как следствие, более экономная работа с ресурсами.
    \item[$-$] Встроенный компилятор, постовляемый совместно с пакетным менеджером Cargo.
    \item[$-$] Кросс-платформенность, от UNIX и MacOS до Web.
    \item[$-$] Крайне побдробные коды ошибок и документация от разработчиков языка.
    \item[$-$] Важно отметить, что язык программирования Rust сопоставим по скорости с такими языками как С и С++,
    предоставляя в то же время более широкий функционал для тестирования кода и контроля памяти.
\end{itemize}

Также были выбраны следующие библиотеки:
\begin{itemize}
    \item[$-$] В качестве графического интерфейса была выбрана библиотека egui\cite{egui} (или иначе crate в контексте языка Rust)
    \item[$-$] Для рендера изображения была выбрана библиотека tiny-skia\cite{tiny-skia}, предоставляющий быстрый CPU-рендеринг
    \item[$-$] Помимо этого egui дает инструментарий для запуска приложения в браузере при непосредственном участии WebAssembly при практически нулевых затратах со стороны программиста.
    \item[$-$] Для тестирования ПО использовались инструменты Cargo\cite{cargo} --- пакетного менеджера языка Rust, поставляемого вместе с компилятором из официального источника.
\end{itemize}

Среда разработки:

В процессе разработки был использован инструмент LSP\cite{lsp} (англ. \textit{Language Server Protocol}), а в частности его реализацию в виде Rust Analyzer~\cite{rust-anal}, позволяющий форматировать исходные коды, а также в процессе их написания обнаружить наличие синтаксических ошибок и некоторых логических, таких как, например, нарушение правила владения\cite{rust-learn}.

В качестве среды разработки был выбран текстовый редактор VIM\cite{vim}, поддерживающий возможность установки плагинов\cite{vim-plugins}, в том числе для работы с LSP\cite{lsp}.
\subsection{Структура классов}

На рисунках \ref{img:classes_A} - \ref{img:classes_C} представлена структура реализуемых классов.

\img{100mm}
{classes_A} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{Структура классов-объектов} % Подпись рисунка

\begin{itemize}
    \item Point – класс точки трехмерного пространства. Хранит координаты в пространстве, владеет методами преобразований точки.
    \item Edge – класс грани. Хранит номера задействованных в грани вершин.
    \item Light – класс источника света.
    \item Model - класс модели. Скрывает конкретную реализацию модели(фигуры) и предоставляет единый интерфейс для работы с ней. Владеет методами преобразования модели, а также методами для получения информации о модели.
    \item Composite - класс композита. Хранит в себе набор моделей, владеет методами для работы с ними.
\end{itemize}

\img{100mm}
{classes_C} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{Структура классов} % Подпись рисунка

\begin{itemize}
    \item Drawer – класс, отвечающий за растеризацию сцены. Хранит полотно для отрисовки. Владеет методами алгоритма теневого z-буфера и формирования объекта для отображения рисунка в главном приложении.
    \item App – точка входа в программу.
    \item Ui - класс, отвечающий за отображение графического интерфейса.
    \item TransformManager – абстракция, содержащия методы трансформмации объектов.
    \item LoadManager - абстракция, содержащия методы загрузки объектов.
    \item Canvas - класс, отвечающий за отображение сцены.
\end{itemize}
\subsection{Реализация алгоритмов}
В листинге \ref{lst:cg} представлена реализация Z-буффера и Гуро на языке Rust.
В листинге \ref{lst:frame_model} представлена реализация 3D модели.

\begin{lstinputlisting}[
        caption={Реализация алгоритмов компьютерной графики.},
        label={lst:cg},
        style={rust},
        linerange={33-262}
    ]{../../../src/app_factory/drawer/drawer_std.rs}
\end{lstinputlisting}

\begin{lstinputlisting}[
        caption={Реализация 3D модели.},
        label={lst:frame_model},
        style={rust},
        linerange={24-290}
    ]{../../../src/models/frame_model.rs}
\end{lstinputlisting}

\subsection{Интерфейс программного обеспечения}

При запуске программы перед пользователем предстает пустая сцена. 
Для операций над объектами, их модифицирования, для управления камерой или освещением в левой части интерфейса определены соответствующие разделы (рисунок~\ref{img:example}).

\img{100mm}{example}{GUI}

Для создания модели пользователю необходимо нажать на соответствующий раздел и выбрать одно из предложенных тел. Далее в разделе моделей пользоватеь может каких-либо образом изменить необходимую модель. (рисунки ~\ref{img:create}-\ref{img:modify}).

\clearpage

\img{100mm}{create}{Раздел создание модели}

\img{100mm}{modify}{Раздел модифицирования модели}
Для перемещения по сцене используются клавиши: W – вперед, S – назад, A – влево, D – вправо, Стрелка вверх - вверх, Стрелка вниз - вниз, R и T - вращение камеры, Z и С - поворот камеры. 
% \clearpage

В разделе камеры находятся следующие параметры: расстояния до ближней и дальней плоскостей пирамиды видимости, угол обзора, позиция камеры в пространстве, углы поворота, скорость перемещения (рисунок~\ref{img:camera}).

\img{100mm}{camera}{Раздел камеры}

\clearpage

На рисунке~\ref{img:example-models} приведен пример работы программы.

\img{100mm}{example-models}{Тестовая сцена}
\subsection*{Вывод}

В данном разделе были рассмотрены средства, с помощью которых было реализовано ПО, а также представлены структуры классов и листинги кода с реализацией алгоритмов компьютерной графики.
